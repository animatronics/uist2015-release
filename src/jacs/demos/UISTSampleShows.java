package jacs.demos;

import jacs.config.MicrocontrollerConnection;
import jacs.player.AnimatronicsShowPlayer;
import jacs.player.FormattedShowData;
import jacs.utilities.AnimatronicsUtilities;

import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.FileNotFoundException;

import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JLabel;

import jmcc.Microcontroller;

/**
 * 
 * Three sample programs can be selected, played, stopped, paused, resumed through this simple tool using a basic Java
 * Swing interface. UIST contestants can use it to test basic animatronics connections, understand the data required by
 * the player, observe servo motions and see the simplest API that can be required to use the code base for show
 * playback. They can easily add their own prerecorded to shows to the list once they are stored in common file formats
 * (WAV for audio and CSV for servo motion). This allows contestants to focus on the authoring tools for producing the
 * shows in these formats, rather than on playback.
 * <p>
 * Three prerecorded shows are provided and can be played through this GUI: <list>
 * <li>
 * SERVO_SWEEP - is a range of motion demonstration for servo motors on 3 pins. There is no audio file. An empty string
 * indicates. Servo motions were generated programmatically and saved to a CSV file. This code expects the servo pins to
 * be on 2,3,4</li>
 * <li>
 * MOUTH_SYNCH - is a single servo test with motions that correspond to the audio. This code expects the servo to be on
 * pin 2.</li>
 * <li>
 * ONE_CHARACTER - is a prototypical animatronics single character show with three servo motion tracks One servo motion
 * track, stored in the first column of the CSV file, represents the mouth. This data was programmatically generated by
 * processing the WAV file. The other two servos represent head and neck motion, easily implemented with a pan and tilt
 * mechanism. Columns 2 and 3 of the CSV file store these motions. This data was generated from real time recorded
 * joystick motion.</li> </list>
 * 
 * <p>
 * Each show requires 2 supporting files, a .WAV file for audio and a .CSV file that has corresponding servo motions
 * <p>
 * Each show requires an array of pin numbers representing the current physical connection of the servos to the servo
 * controller card. If the servos are moved to different pins, then the corresponding row in the
 * prerecordedShowsPinConfigurations array must be changed to reflect it. No other change is required.
 * <p>
 * Supporting Data Files are provided in the data folder as samples.
 * 
 * 
 * @author Ginger Alford
 *
 */
public class UISTSampleShows extends JFrame implements ActionListener {

	private static final long serialVersionUID = 1L;

	/**
	 * Data files associated with prerecorded shows. Alter corresponding data in each array to vary the show or Append
	 * new data to each array to add
	 */
	public static final int SERVO_SWEEP = 0; // 1 audio, 3 motors not synched to audio
	public static final int MOUTH_SYNCH = 1; // 1 mouth synched to audio
	public static final int ONE_CHARACTER = 2; // 1 mouth synched to audio and 2 motors for head and neck
	public static final int ADD_YOUR_OWN = 3; // placeholder to show where to add your own show files

	public static final String[] prerecordedShows = new String[] {
	/* 0 */"Servo Sweep",
	/* 1 */"Mouth Synch Demo",
	/* 2 */"One Character",
	/* 3 */"<add your own here>" };

	// empty string indicates no audio
	public static final String[] prerecordedShowsAudioFiles = new String[] {
	/* 0 */"",
	/* 1 */"data/MouthSynchTestOneMinute.wav",
	/* 2 */"data/AlpacaOESISDemo.wav",
	/* 3 */"" };

	public static final String[] prerecordedShowsMotionFiles = new String[] {
	/* 0 */"data/ThreeServoMotion.csv",
	/* 1 */"data/MouthSynchTestOneMinute.csv",
	/* 2 */"data/AlpacaOESISDemo.csv",
	/* 3 */"" };

	public static final byte[][] prerecordedShowsPinConfigurations = new byte[][] {
	/* 0 */{ (byte) 2, (byte) 3, (byte) 4 },
	/* 1 */{ (byte) 2 },
	/* 2 */{ (byte) 2, (byte) 3, (byte) 4 },
	/* 3 */{} };

	public static final String[] userMessages = new String[] {
	/* 0 */"Attach servos to pins 2,3,4 for SERVO SWEEP",
	/* 1 */"Attach servo to pins 2 for MOUTH_SYNCH and observe how motion corresponds to audio.",
	/* 2 */"Attach servos to pins 2,3,4 for ONE_CHARACTER (Alpaca)",
	/* 3 */"Edit the code to add your own files for audio (WAV) and servo motion (CSV)." };

	// Sample shows
	JLabel showListLabel;
	JComboBox<String> showListComboBox; // Choice of shows

	// Playback controls
	JButton playButton;
	JButton stopButton;
	JButton pauseButton;
	JButton resumeButton;

	// User information
	JLabel message;

	// Controls to update connection
	JButton connectButton; // For updating microController Connection
	JLabel portChoiceLabel;
	JComboBox<String> portComboBox;

	AnimatronicsShowPlayer show; //

	/**
	 * 
	 * 
	 * @param player
	 */
	UISTSampleShows(AnimatronicsShowPlayer player) {

		this.show = player;

		this.setLayout(new FlowLayout());
		this.setVisible(true);
		this.setSize(600, 300);

		// Controls for prerecorded shows
		showListLabel = new JLabel("Show List:");

		showListComboBox = new JComboBox(prerecordedShows);
		showListComboBox.addActionListener(this);
		showListComboBox.setActionCommand("LOAD_SHOW");

		playButton = new JButton("PLAY");
		playButton.addActionListener(this);
		playButton.setActionCommand("PLAY");

		stopButton = new JButton("STOP");
		stopButton.addActionListener(this);
		stopButton.setActionCommand("STOP");

		pauseButton = new JButton("PAUSE");
		pauseButton.addActionListener(this);
		pauseButton.setActionCommand("PAUSE");

		resumeButton = new JButton("RESUME");
		resumeButton.addActionListener(this);
		resumeButton.setActionCommand("RESUME");

		message = new JLabel("messages");

		// Controls for updating microcontroller connection

		// connectButton = new JButton("CONNECT DEVICE");
		// connectButton.addActionListener(this);
		// connectButton.setActionCommand("CONNECT");
		//
		// portChoiceLabel = new JLabel("Select Port");
		// portChoiceLabel.setVisible(false);
		//
		// portComboBox = new JComboBox<String>(new String[] {});
		// portComboBox.addActionListener(this);
		// portComboBox.setActionCommand("SELECT_PORT");
		// portComboBox.setVisible(false);

		this.add(showListLabel); // Add component
		this.add(showListComboBox);

		this.add(playButton);
		this.add(stopButton);
		this.add(pauseButton);
		this.add(resumeButton);
		this.add(message);

		// Add components for updating microcontroller connection
		// this.add(connectButton);
		// this.add(portChoiceLabel);
		// this.add(portComboBox);

		this.validate();
		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

		// Set PreRecorded Sample Shows
		showListComboBox.setSelectedIndex(0);
		loadPreRecordedShowData(0);

	}

	@Override
	public void actionPerformed(ActionEvent e) {
		String action = e.getActionCommand();

		if (action.equals("LOAD_SHOW")) {
			int showChoice = (int) showListComboBox.getSelectedIndex();
			message.setText(userMessages[showChoice]);
		}

		if (action.equals("PLAY")) {
			try {
				int showChoice = (int) showListComboBox.getSelectedIndex();
				System.out.println("Show Selection: " + prerecordedShows[showChoice]);
				FormattedShowData showData = loadPreRecordedShowData(showChoice);
				if (showData != null) {
					show.playShow(showData);
					message.setText("playing show...");
				} else
					message.setText("problem formatting show data for " + prerecordedShows[showChoice]);

			} catch (FileNotFoundException e1) {
				message.setText("File not found" + e1.getMessage());
			} catch (Exception e2) {
				message.setText("Error: " + e2.getMessage());
			}

		}

		else if (action.equals("STOP")) {
			show.stopShow();
			message.setText("stopping show...");
		}

		else if (action.equals("PAUSE")) {
			show.pauseShow();
			message.setText("pausing show...");
		}

		else if (action.equals("RESUME")) {
			show.resumeShow();
			message.setText("resuming show...");
		}

	}

	//

	/**
	 * 
	 * Convert show data into standard format
	 * <p>
	 * Here, all data is prerecorded and read from .WAV files and .CSV files, each column in the CSV file is a servo
	 * motion track pin data maps each column of CSV file (single motion track) to a specific pin. In the one_character
	 * show, the first column stores motion data synchronized to the .WAV file and the second two columns contain data
	 * captured in real time from a joystick recording and correspond to two servos connected to a pan and tilt kit
	 * 
	 * @param showChoice
	 */
	private FormattedShowData loadPreRecordedShowData(int showChoice) {
		FormattedShowData showData = null;
		String audioFile;
		byte[][] servoMotions;
		byte[] dummy = {};
		byte[] pins;
		if (showChoice < prerecordedShows.length) {

			try {
				audioFile = prerecordedShowsAudioFiles[showChoice];
				pins = prerecordedShowsPinConfigurations[showChoice];

				message.setText(userMessages[showChoice] + " using " + audioFile + " "
						+ prerecordedShowsMotionFiles[showChoice] + " with " + pins.length + " tracks");

				servoMotions = AnimatronicsUtilities.getBytes(prerecordedShowsMotionFiles[showChoice], pins.length);

				showData = new FormattedShowData(audioFile, pins, servoMotions, dummy);

			} catch (FileNotFoundException e1) {
				message.setText("File " + prerecordedShowsMotionFiles[showChoice] + " not found.");

			} catch (Exception e1) {
				message.setText("Error: " + e1.getMessage());
			}
		}
		return showData;
	}

	public static void main(String args[]) throws Exception {

		MicrocontrollerConnection mc = new MicrocontrollerConnection(Microcontroller.POLOLU_MICRO_MAESTRO);

		AnimatronicsShowPlayer player;

		player = new AnimatronicsShowPlayer(mc);

		new UISTSampleShows(player);

	}
}
